
#include <cerrno>
#include <cstring>
#include <algorithm>
#include <string>
#include <iostream>
#include <sstream>
#include <future>

#include <unistd.h>
#include <sys/socket.h>  // Socket interface
#include <arpa/inet.h>   // Utility network functions
#include <netinet/in.h>  // Internet protocol interface

// Manages the coniguration of the socket.
struct Config
{
  int network;    // Specifies the network layer.
  int transport;  // Selects a transport profile.
  int port;       // The application port number.
};

bool parse_command_line(int argc, char** argv, Config&);
void run_stream_server(int sd);
void run_stream_client(int cd, std::string);
void run_datagram_server(int sd);

int
usage()
{
  std::cout << "usage: discardd <ipv4|ipv6> <tcp|udp> <port-number>\n\n";
  return 0;
}

int
main(int argc, char* argv[])
{
  // Parse the command line arguments.
  Config cfg;
  if (!parse_command_line(argc, argv, cfg)) {
    usage();
    return -1;
  }

  // Create the socket.
  int sd = socket(cfg.network, cfg.transport, 0);
  if (sd < 0) {
    std::cout << "error (socket): " << std::strerror(errno) << '\n';
    return -1;
  }

  // Bind the socket to the local address. We need
  // to set up a socket address for this operation.
  if (cfg.network == AF_INET) {
    // Initialize the IPv4 address.
    sockaddr_in addr;
    std::memset(&addr, 0, sizeof(addr)); // Zero-initialize the address
    addr.sin_family = AF_INET;           // Set the address family
    addr.sin_addr.s_addr = INADDR_ANY;   // Allow messages from anywhere
    addr.sin_port = htons(cfg.port);     // Set the port number

    // Bind the socket to the address.
    if (bind (sd, (sockaddr*)&addr, sizeof(addr)) < 0) {
      std::cout << "error (bind): " << std::strerror(errno) << '\n';
      return -1;
    }
  } else {
    // Initialize the IPv6 address.
    sockaddr_in6 addr;
    std::memset(&addr, 0, sizeof(addr)); // Zero-initialize the address
    addr.sin6_family = AF_INET6;         // Set the address family
    addr.sin6_addr = in6addr_any;        // Allow messages from anywhere
    addr.sin6_port = htons(cfg.port);    // Set the port number

    // Bind the socket to the address.
    if (bind (sd, (sockaddr*)&addr, sizeof(addr)) < 0) {
      std::cout << "error (bind): " << std::strerror(errno) << '\n';
      return -1;
    }
  }

  // Run a server based on the requested transport type.
  if (cfg.transport == SOCK_STREAM)
    run_stream_server(sd);
  else
    run_datagram_server(sd);

  // Close the socket and exit.
  shutdown(sd, SHUT_RDWR);
  close(sd);
}

bool
parse_command_line(int argc, char** argv, Config& cfg)
{
  if (argc != 4) {
    std::cout << "error (config): wrong number of command line arguments\n";
    return false;
  }

  // Get the network layer protocol.
  std::string network = argv[1];
  if (network == "ipv4") {
    cfg.network = AF_INET;
  } else if (network == "ipv6") {
    cfg.network = AF_INET6;
  } else {
    std::cout << "error (config): network must be 'ipv4' or 'ipv6'\n";
    return false;
  }

  // Get the transport layer protocol.
  std::string transport = argv[2];
  if (transport == "tcp") {
    cfg.transport = SOCK_STREAM;
  } else if (transport == "udp")
    cfg.transport = SOCK_DGRAM;
  else {
    std::cout << "error (config): transport must be 'tcp' or 'udp'\n";
    return false;
  }

  // Get the port number.
  std::string port = argv[3];
  std::stringstream ss(port);
  ss >> cfg.port;
  if (!ss) {
    std::cout << "error (config): invalid port number\n";
    return false;
  }

  return true;
}

// Returns a string representation of the given address.
std::string
get_address_name(sockaddr_storage& addr)
{
  // Get the address field from the connected end point.
  void* ptr;     // Points to the actual address field
  if (addr.ss_family == AF_INET) {
    sockaddr_in* p = (sockaddr_in*)&addr;
    ptr = &p->sin_addr;
  } else if (addr.ss_family == AF_INET6) {
    sockaddr_in6* p = (sockaddr_in6*)&addr;
    ptr = &p->sin6_addr;
  } else {
    std::cout << addr.ss_family << '\n';
    return "<unknown>";
  }
  
  // Get a textual representaiton of the client's address.
  char name[64]; // Will store the address string
  if (!inet_ntop(addr.ss_family, ptr, name, 64))
    return "<error>";
  else
    return name;
}

void
run_stream_client (int cd, std::string name)
{
  constexpr int bufsize = 1 << 16;
  std::cout << '[' << name << ']' << " connected\n";
  while (1) {
    char buf[bufsize]; // Stores the messages

    // Block until there is data to be recieved. This returns
    // the number of bytes available in the messge queue.
    int n = recv(cd, buf, bufsize, 0);
    if (n <= 0) {
      if (n == 0) {
        shutdown(cd, SHUT_RDWR);
        close(cd);
      } else {
        std::cout << "error (recv): " << std::strerror(errno) << '\n';
      }
      return ;
    }

    // Print the message. Be sure to null-terminate the text 
    // before printing it.
    buf[n] = 0;
    std::cout << '[' << name << ']' << " received: " << buf << '\n';
  }
}

void
run_stream_server(int sd) {
  // Store the list of clients that we're waiting for closure.
  std::vector<std::future<void>> futures;

  // Start listening for connections. SOMAXCONN is the largest
  // possible backlog of unserviced requests on Linux.
  if (listen(sd, SOMAXCONN) < 0) {
    std::cout << "error (listen): " << std::strerror(errno) << '\n';
    return;
  }

  // Process 'count' numbers of connections before terminating.
  int count = 1;
  while (count) {
    sockaddr_storage addr;           // Stores the address of the client.
    socklen_t length = sizeof(addr); // Length of the stored address.

    // Accept the next queued connection. Note that this will
    // block (stop the program) if no connections are queued.
    // If connections are available, this returns immediately.
    //
    // The value cd (client descriptor) is a socket descriptor
    // for the connected client.
    int cd = accept (sd, (sockaddr*)&addr, &length);
    if (cd < 0) {
      std::cout << "error (accept): " << std::strerror(errno) << '\n';
      continue;
    }

    // Launch a thread to process the client connection and
    // save its future result in futures.
    std::string name = get_address_name(addr);
    std::future<void> f = std::async(run_stream_client, cd, name);
    futures.push_back(std::move(f));

    --count;
  }

  // Make sure that all our threads have finished.
  for (std::future<void>& f : futures)
    f.get();
}

void
run_datagram_server(int sd)
{
  constexpr int bufsize = 1 << 16;
  int count = 3;
  while (count) {
    sockaddr_storage addr;           // Stores the address of the client.
    socklen_t length = sizeof(addr); // Length of the stored address.
    char buf[bufsize];     // A 64K buffer, stores the message.

    // Receive a message on this socket. Returns the number
    // of bytes received. If n is 0, then the sending service
    // has closed.
    int n = recvfrom(sd, buf, bufsize, 0, (sockaddr*)&addr, &length);
    if (n < 0) {
      std::cerr << "error (recvfrom): " << std::strerror(errno) << '\n';
      return;
    } else if (n > 0) {

      std::string name = get_address_name(addr);

      buf[n] = 0; // Null-terminate the message.
      std::cout << '[' << name << ']' << " received: " << buf;
    }
    
    --count;
  }
}

